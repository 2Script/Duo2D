#version 450
#extension GL_EXT_buffer_reference : require


struct draw_command {
    uint indexCount;
    uint instanceCount;
    uint firstIndex;
    int  vertexOffset;
    uint firstInstance;
};


layout(buffer_reference, std430, buffer_reference_align = 8) writeonly buffer PositionsBuffer { 
	uvec2 positions[];
};

layout(buffer_reference, std430, buffer_reference_align = 8) buffer DrawCommandsBuffer { 
	draw_command draw_cmds[];
};

layout(buffer_reference, std430, buffer_reference_align = 8) buffer CountBuffer { 
	uint draw_count;
	uint rect_limit;
	
	uvec2 _padding;
};


layout(buffer_reference, std430, buffer_reference_align = 8) readonly buffer Registers { 
	CountBuffer count_buff;
	PositionsBuffer pos_buff;
	DrawCommandsBuffer draw_cmd_buff;
};

layout(std430, push_constant) uniform PushConstants {
    Registers addrs;
} push_constants;


layout (local_size_x = 16, local_size_y = 16, local_size_z = 1) in;


void main() {
	const uint x = gl_GlobalInvocationID.x;
	const uint y = gl_GlobalInvocationID.y;
	const uint i = x + (16 * y);
	
	const uint n = push_constants.addrs.count_buff.rect_limit.x;

	if(i >= n)
		return;

	push_constants.addrs.pos_buff.positions[i] = uvec2(100 * x, 50 * y);
	atomicMax(push_constants.addrs.draw_cmd_buff.draw_cmds[0].instanceCount, i + 1);

	//push_constants.addrs.draw_cmd_buff.draw_cmds[i] = draw_command(6, 3, 0, 0, 0);
	//atomicMax(push_constants.addrs.count_buff.draw_count, i + 1);
}